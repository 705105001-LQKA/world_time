import 'package:flutter/material.dart';
import 'package:flutter/services.dart';
import 'package:get/get.dart';
import 'package:intl/intl.dart';
import 'package:timezone/timezone.dart' as tz;
import '../../domain/entities/city_time.dart';
import '../controllers/time_controller.dart';

class CityTimeRow extends StatelessWidget {
  final CityTime cityTime;
  final DateTime utcNow;
  final tz.TZDateTime hcmStart;
  final ScrollController scrollController;

  const CityTimeRow({
    super.key,
    required this.cityTime,
    required this.utcNow,
    required this.hcmStart,
    required this.scrollController,
  });

  @override
  Widget build(BuildContext context) {
    final location = tz.getLocation(cityTime.timezone);
    final localNow = tz.TZDateTime.from(utcNow, location);
    debugPrint('üïí ${cityTime.cityName} shows: ${localNow.hour}:${localNow.minute}');
    final controller = Get.find<TimeController>();

    String _formatUtcOffset(Duration offset) {
      final totalMinutes = offset.inMinutes;
      final sign = totalMinutes >= 0 ? '+' : '-';
      final absMinutes = totalMinutes.abs();
      final hours = (absMinutes ~/ 60).toString().padLeft(2, '0');
      final minutes = (absMinutes % 60).toString().padLeft(2, '0');
      return 'UTC$sign$hours:$minutes';
    }

    return Padding(
      padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 1),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          // Header: city name + meta + close button
          Row(
            mainAxisSize: MainAxisSize.max,
            crossAxisAlignment: CrossAxisAlignment.center,
            children: [
              Expanded(
                child: Row(
                  crossAxisAlignment: CrossAxisAlignment.center,
                  children: [
                    SizedBox(
                      width: 140,
                      child: Text(
                        cityTime.cityName,
                        style: const TextStyle(fontSize: 16, fontWeight: FontWeight.bold),
                        overflow: TextOverflow.ellipsis,
                      ),
                    ),
                    const SizedBox(width: 8),
                    Flexible(
                      child: Obx(() {
                        final start = controller.selectedStartUtc.value;
                        final end = controller.selectedEndUtc.value;
                        final selectedDateUtc = controller.selectedDate.value;

                        // If there is a start/end selection, show the range in city's local tz
                        if (start != null && end != null) {
                          final localStart = tz.TZDateTime.from(start, location);
                          final localEnd = tz.TZDateTime.from(end, location);
                          final label =
                              '${DateFormat('HH:mm E dd/MM').format(localStart)} ‚Üí ${DateFormat('HH:mm E dd/MM').format(localEnd)}';
                          return Text(
                            label,
                            style: const TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
                            overflow: TextOverflow.ellipsis,
                          );
                        }

                        // If user selected a calendar date, show weekday + date (based on that date in city's tz)
                        if (selectedDateUtc != null) {
                          final tzDate = tz.TZDateTime.from(selectedDateUtc, location);
                          final label = '${DateFormat.E().format(tzDate)}, ${DateFormat('dd MMM yyyy').format(tzDate)}';
                          return Text(
                            label,
                            style: const TextStyle(fontSize: 12, fontWeight: FontWeight.w500),
                            overflow: TextOverflow.ellipsis,
                          );
                        }

                        // Default: show timezone ¬∑ HH:mm ¬∑ weekday, date ¬∑ UTC offset
                        final weekday = DateFormat.E().format(localNow);
                        final date = DateFormat('dd MMM').format(localNow);
                        return Row(
                          children: [
                            Flexible(
                              child: Text(
                                cityTime.timezone,
                                style: const TextStyle(fontSize: 12),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            const SizedBox(width: 6),
                            Text(
                              '${localNow.hour.toString().padLeft(2, '0')}:${localNow.minute.toString().padLeft(2, '0')}',
                              style: const TextStyle(fontSize: 12),
                            ),
                            const SizedBox(width: 6),
                            Flexible(
                              child: Text(
                                '$weekday, $date',
                                style: const TextStyle(fontSize: 12),
                                overflow: TextOverflow.ellipsis,
                              ),
                            ),
                            const SizedBox(width: 12),
                            Text(
                              _formatUtcOffset(localNow.timeZoneOffset),
                              style: const TextStyle(fontSize: 12, color: Colors.black54),
                            ),
                          ],
                        );
                      }),
                    ),
                  ],
                ),
              ),

              IconButton(
                icon: const Icon(Icons.close, color: Colors.red),
                tooltip: 'X√≥a th√†nh ph·ªë',
                padding: EdgeInsets.zero,
                onPressed: () {
                  Get.defaultDialog(
                    title: 'X√°c nh·∫≠n x√≥a',
                    middleText: 'B·∫°n c√≥ ch·∫Øc mu·ªën x√≥a ${cityTime.cityName} kh·ªèi danh s√°ch?',
                    textCancel: 'H·ªßy',
                    textConfirm: 'X√≥a',
                    confirmTextColor: Colors.white,
                    onConfirm: () {
                      controller.removeCity(cityTime.cityName);
                      HapticFeedback.lightImpact();
                      Get.back();
                    },
                  );
                },
                iconSize: 24.0,
                constraints: const BoxConstraints(minWidth: 0, minHeight: 0, maxWidth: 24, maxHeight: 24),
                visualDensity: VisualDensity.compact,
              ),
            ],
          ),

          const SizedBox(height: 8),

          // Timeline horizontal
          Obx(() {
            final selectedStart = controller.selectedStartUtc.value;
            final selectedEnd = controller.selectedEndUtc.value;
            final selectedDateUtc = controller.selectedDate.value;

            final List<Widget> timelineChildren = [];

            // Normalize selection for comparisons
            DateTime? start = selectedStart;
            DateTime? end = selectedEnd;
            if (start != null && end != null && end.isBefore(start)) {
              final temp = start;
              start = end;
              end = temp;
            }

            for (int i = 0; i < 24; i++) {
              final utcStart = hcmStart.add(Duration(hours: i)).toUtc();
              final utcEnd = utcStart.add(const Duration(hours: 1));

              final localStart = tz.TZDateTime.from(utcStart, location);
              final localEnd = tz.TZDateTime.from(utcEnd, location);

              final isCurrent = localNow.isAfter(localStart) && localNow.isBefore(localEnd);
              final isStart = selectedStart != null && selectedStart == utcStart;
              final isEnd = selectedEnd != null && selectedEnd == utcEnd;
              final isTagged = start != null &&
                  end != null &&
                  !utcStart.isBefore(start) &&
                  utcStart.isBefore(end);

              Color? bgColor;
              Gradient? gradient;
              Color textColor = Colors.black;
              String emoji = '‚ùì';

              final isMidnight = localStart.hour == 0;

              // determine default colors/emojis
              if (isMidnight) {
                bgColor = Colors.black87;
                textColor = Colors.white;
                emoji = 'üåô';
              } else if (localStart.hour >= 1 && localStart.hour <= 5) {
                bgColor = Colors.grey.shade700;
                textColor = Colors.white;
                emoji = 'üåô';
              } else if (localStart.hour >= 6 && localStart.hour <= 11) {
                bgColor = Colors.yellow.shade200;
                emoji = 'üåÖ';
              } else if (localStart.hour >= 12 && localStart.hour <= 17) {
                bgColor = Colors.orange.shade200;
                emoji = 'üåá';
              } else {
                bgColor = Colors.purple.shade200;
                emoji = 'üåÉ';
              }

              // override coloring for selection/current states
              if (isCurrent && (isStart || isEnd)) {
                gradient = LinearGradient(
                  colors: [Colors.blueAccent, Colors.green.shade700],
                  begin: Alignment.topLeft,
                  end: Alignment.bottomRight,
                );
                textColor = Colors.white;
                emoji = 'üïí';
              } else if (isCurrent) {
                bgColor = Colors.blueAccent;
                textColor = Colors.white;
                emoji = 'üïí';
              } else if (isStart || isEnd) {
                bgColor = Colors.green.shade700;
                textColor = Colors.white;
              } else if (isTagged) {
                bgColor = Colors.green.shade300;
              }

              // Compute display for midnight: if selectedDateUtc present, use that date in city's tz
              Widget content;
              if (isMidnight) {
                final displayDateTz = selectedDateUtc != null
                    ? tz.TZDateTime.from(selectedDateUtc, location)
                    : localStart;
                // build midnight children (when selectedDate present, we DO NOT show current-time marker)
                content = Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(
                      DateFormat.E().format(displayDateTz).toUpperCase(),
                      style: const TextStyle(color: Colors.white, fontSize: 10),
                    ),
                    Text(
                      DateFormat('dd MMM').format(displayDateTz),
                      style: const TextStyle(color: Colors.white, fontSize: 12, fontWeight: FontWeight.bold),
                    ),
                    if (selectedDateUtc == null && isCurrent) const SizedBox(height: 2),
                    if (selectedDateUtc == null && isCurrent)
                      const Text('00:00  üïí', style: TextStyle(color: Colors.white, fontSize: 12)),
                  ],
                );
              } else {
                content = Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text(DateFormat('HH:mm').format(localStart), style: TextStyle(fontSize: 12, color: textColor)),
                    Text(emoji, style: TextStyle(fontSize: 14, color: textColor)),
                  ],
                );
              }

              final child = AnimatedContainer(
                duration: const Duration(milliseconds: 300),
                curve: Curves.easeInOut,
                width: 60,
                height: 50,
                alignment: Alignment.center,
                margin: const EdgeInsets.symmetric(horizontal: 1),
                decoration: BoxDecoration(
                  color: gradient == null ? bgColor : null,
                  gradient: gradient,
                  borderRadius: BorderRadius.circular(4),
                  boxShadow: isCurrent ? [BoxShadow(color: Colors.black26, blurRadius: 4, offset: const Offset(0, 1))] : null,
                ),
                child: content,
              );

              timelineChildren.add(
                GestureDetector(
                  onDoubleTap: () {
                    final currentTapStart = utcStart;
                    final currentTapEnd = utcEnd;

                    DateTime newStart;
                    DateTime newEnd;

                    final curStart = controller.selectedStartUtc.value;
                    final curEnd = controller.selectedEndUtc.value;

                    if (curStart == null && curEnd == null) {
                      // first tap: select 1-hour slot
                      newStart = currentTapStart;
                      newEnd = currentTapEnd;
                    } else {
                      // subsequent tap: keep existing normalized start, update end to tapped end,
                      // if tapped end is before start -> swap and expand by 1 hour (your requested behavior)
                      DateTime s = curStart!;
                      DateTime e = curEnd!;
                      if (e.isBefore(s)) {
                        final tmp = s;
                        s = e;
                        e = tmp;
                      }

                      newStart = s;
                      newEnd = currentTapEnd;

                      if (newEnd.isBefore(newStart)) {
                        DateTime swappedStart = newEnd;
                        DateTime swappedEnd = newStart;
                        swappedStart = swappedStart.subtract(const Duration(hours: 1));
                        swappedEnd = swappedEnd.add(const Duration(hours: 1));
                        newStart = swappedStart;
                        newEnd = swappedEnd;
                      }
                    }

                    controller.selectedStartUtc.value = newStart;
                    controller.selectedEndUtc.value = newEnd;
                  },
                  child: child,
                ),
              );
            }

            return SingleChildScrollView(
              controller: scrollController,
              scrollDirection: Axis.horizontal,
              child: Row(children: timelineChildren),
            );
          }),
        ],
      ),
    );
  }
}