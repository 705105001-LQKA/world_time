import 'package:flutter/material.dart';
import 'package:get/get.dart';
import 'package:get_storage/get_storage.dart';
import 'package:timezone/timezone.dart' as tz;
import 'package:timezone/data/latest.dart' as tz_data;

import '../../domain/entities/city_time.dart';

class TimeController extends GetxController {
  final cityTimes = <CityTime>[].obs;
  final selectedHour = DateTime.now().hour.obs;
  final storage = GetStorage();
  final utcNow = DateTime.now().toUtc().obs;
  final selectedStartUtc = Rx<DateTime?>(null);
  final selectedEndUtc = Rx<DateTime?>(null);

  @override
  void onInit() {
    super.onInit();
    tz_data.initializeTimeZones();
    loadCities();
  }

  void addCity(String cityName, String timezone) {
    const int maxCities = 15;

    // Kiá»ƒm tra sá»‘ lÆ°á»£ng
    if (cityTimes.length >= maxCities) {
      Get.snackbar(
        'Giá»›i háº¡n thÃ nh phá»‘',
        'Báº¡n chá»‰ cÃ³ thá»ƒ lÆ°u tá»‘i Ä‘a $maxCities thÃ nh phá»‘.',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.black87,
        colorText: Colors.white,
      );
      return;
    }

    // NgÄƒn thÃªm trÃ¹ng (theo timezone hoáº·c theo tÃªn tuá»³ Ã½)
    final exists = cityTimes.any((c) =>
    c.cityName.toLowerCase() == cityName.toLowerCase() ||
        c.timezone == timezone);
    if (exists) {
      Get.snackbar(
        'ÄÃ£ cÃ³ trong danh sÃ¡ch',
        'ThÃ nh phá»‘ nÃ y Ä‘Ã£ cÃ³ trong danh sÃ¡ch.',
        snackPosition: SnackPosition.BOTTOM,
        backgroundColor: Colors.black87,
        colorText: Colors.white,
      );
      return;
    }

    final location = tz.getLocation(timezone);
    final now = tz.TZDateTime.now(location);
    final cityTime = CityTime(cityName: cityName, timezone: timezone, time: now);

    cityTimes.add(cityTime);
    saveCities();
  }

  void removeCity(String cityName) {
    cityTimes.removeWhere((ct) => ct.cityName == cityName);
    saveCities();
  }

  void updateTimes() {
    final now = DateTime.now();
    utcNow.value = now.toUtc(); // cáº­p nháº­t thá»i gian dÃ¹ng cho UI

    debugPrint('â± updateTimes() called at: $now');

    final updated = cityTimes.map((ct) {
      final location = tz.getLocation(ct.timezone);
      final local = tz.TZDateTime.now(location);
      debugPrint('ðŸ“ ${ct.cityName} local time: $local');
      return CityTime(cityName: ct.cityName, timezone: ct.timezone, time: local);
    }).toList();

    cityTimes.assignAll(updated);
  }

  void saveCities() {
    final list = cityTimes.map((ct) => {
      'city': ct.cityName,
      'timezone': ct.timezone,
    }).toList();
    storage.write('cities', list);
  }

  void loadCities() {
    final list = storage.read<List>('cities') ?? [];
    final loaded = list.map((item) {
      return CityTime(
        cityName: item['city'],
        timezone: item['timezone'],
        time: tz.TZDateTime.now(tz.getLocation(item['timezone'])),
      );
    }).toList();
    cityTimes.assignAll(loaded);
  }

  void reorderCity(int oldIndex, int newIndex) {
    if (newIndex > oldIndex) newIndex -= 1;
    final item = cityTimes.removeAt(oldIndex);
    cityTimes.insert(newIndex, item);

    saveCities();
  }

  void moveCityUp(String cityName) {
    final index = cityTimes.indexWhere((c) => c.cityName == cityName);
    if (index > 0) {
      final temp = cityTimes[index];
      cityTimes[index] = cityTimes[index - 1];
      cityTimes[index - 1] = temp;
    }
  }

  void moveCityDown(String cityName) {
    final index = cityTimes.indexWhere((c) => c.cityName == cityName);
    if (index < cityTimes.length - 1 && index != -1) {
      final temp = cityTimes[index];
      cityTimes[index] = cityTimes[index + 1];
      cityTimes[index + 1] = temp;
    }
  }

  void showSafeSnackbar(String title, String message) {
    Get.showSnackbar(
      GetSnackBar(
        titleText: Text(
          title,
          style: const TextStyle(color: Colors.white, fontWeight: FontWeight.bold),
        ),
        messageText: Text(
          message,
          style: const TextStyle(color: Colors.white),
        ),
        snackPosition: SnackPosition.TOP,
        snackStyle: SnackStyle.FLOATING,
        margin: const EdgeInsets.only(top: 0, left: 47, right: 34),
        backgroundColor: Colors.redAccent,
        borderRadius: 8,
        duration: const Duration(seconds: 2),
        isDismissible: true,
      ),
    );
  }
}